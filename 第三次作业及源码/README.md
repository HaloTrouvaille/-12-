# 实验题目：多线程编程
## 实验目的
(1) 掌握基于pthread线程库的多线程编程技术  
(2) 掌握基本的线程间同步技术(sem,mutex)  
(3) 理解共享资源并掌握其操作方法  
## 实验内容
读者-写者问题多线程实现  
*  一个数据集（如数据、文件等）被N个线程读写；  
*  一些线程只要求读数据集内容，称为读者 (Reader)，实验读者数不少于6个；  
*  另些线程要求修改数据集内容，称为写者 (Writer)，实验写者数不少于3个；  
*  多个读者可以同时读数据集内容，不需要互斥操作；  
*  一个写者不能和其他写者或读者同时访问数据集，换句话说，写者和其他写者或读者之间必须互斥操作；
*  读者优先：如果有读者，写者需要等待！用于更新不频繁或更新影响不显著、读者较多的场合；
*  写者优先：如果有写者，读者需要等待！用于更新频繁或更新影响显著的场合。
## 实验过程与结果
### 实验过程描述
(1)读者优先实现：在读者优先实验中，创建6个读者线程和3个写者线程，初始数据集设为data=0。此外还通过创建1个写互斥锁实现一个写者不能和其他写者或读者同时访问数据集，此实验流程图如下图所示。此部分代码结构及相应注释如下图所示。 
![读者优先流程图](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/读者优先流程图.png)  
![读者优先代码结构](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/读者优先结构.png)  
另外，编写读者线程运行函数thread_function_read()。由于由于读者之间可以同时读数据集内容，不需要互斥操作，因此不需要添加读互斥锁；但读者和写者之间不能同时访问数据集，因此需要添加写互斥锁。此外，本实验要求实现读者优先，即如果有读者(可能一个或多个)，写者需要等待当前全部读者完成，因此通过设置外部计数变量reader_counter来实现此要求。具体实现过程为：每次读者进入都会给计数器+1，且只要有1个读者进入，就给读者线程加上写互斥锁。这样做一方面保证读者和写者不会同时访问数据集；另一方面，每次读者完成后都会给计数器-1，且直到当前所有读者都读完（即计数器清零），才给读者线程解除写互斥锁，从而该写互斥锁可以保证当前所有读者读完后，才有可能将资源交给写者，进而也保证了读者优先。此部分代码结构如下图所示。  
(**注：6个读者线程通过各自的id来区分；此方法只使用了写互斥锁，而且设置所有当前读者读完后才释放写互斥锁，这样做也允许读者可以同时读数据集内容**)   
![读者优先读函数](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/读者优先读函数.png)  
最后，编写写者线程运行函数thread_function_write()。本实验设置写者每次向数据集data写入一个随机数（通过rand函数实现）。由于写者之间不能同时访问数据集，因此需要添加写互斥锁。此部分代码结构如下图所示。  
(**注：3个写者线程通过各自的id来区分；实验还要求写者和读者之间也不能同时访问数据集，这一点在设计读者优先部分时已经通过写互斥锁实现了**)  
![读者优先写函数](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/读者优先写函数.png)  
(2)写者优先实现：在写者优先实验中，同样创建6个读者线程和3个写者线程，初始数据集设为data=0。此外通过读者锁、写者锁与两个信号量实现防止冲突。写者线程中，通过互斥锁限制只有一个写者修改数据，并通过信号量限制后续读者加入待读队列中。即通过writerCnt作为计数器，当其为1说明有写者参与，则需要上互斥锁防止读者进入数据集。此实验流程图如下图所示。此部分代码结构如下图所示。  
![写者优先流程图](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/写者优先流程图.png)  
![写者优先写函数](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/写者优先写函数.png)  
另外，编写读者线程运行函数。通过互斥锁实现写者线程优先且只被一个读者占有，即在释放互斥锁时写者优先获取。利用readerCnt作为计数器，当其为1说明有读者在读，此时应上互斥锁防止写者线程写入数据集。此部分代码结构如下图所示。  
![写者优先读函数](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/写者优先读函数.png)    
### 实验结果分析
(1)运行读者优先实验程序，运行结果如下图所示。  
![读者优先实验结果](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/读者优先实验结果.png)  
实验结果分析：首先读者之间不存在互斥作用，可以同时准备好再读数据集；其次，写者之间以及写者和读者之间存在互斥作用，1个写者在准备和写的时候，不会出现其他写者或读者同时访问数据集的情况；最后，读者优先，前5个读者在同一时间段读数据集，第1个写者在等待这5个读者读完后才进行写操作。  
(**注：第6个读者，没有赶在前5个读者读完之前进入，而被3个写者依次占据资源，因此才在最后读数据集，而此时读的内容是最后一个写者所写的内容**)  
(2)运行写者优先实验程序，运行结果如下图所示。  
![写者优先实验结果](https://github.com/HaloTrouvaille/Embedded-Software-Group-12/blob/master/第三次作业及源码/图片/写者优先实验结果.png)  
(**注：不同线程间通过id进行区分**)  
实验结果分析：由上图可见，某写者线程在开始写到结束写阶段，不会出现其他写者或读者同时进入数据集的情况。且写者优先，写者先写完后，即数据集已经改变后，读者线程才进行读操作。  
## 实验总结
通过本次实验，我们小组对基于pthread多线程编程有了更深的理解，并且通过互斥锁、信号量等方法实现了线程间的同步技术。实验期间也遇到了些许问题，如对线程相关函数理解不到位、编译过程忘加-lpthread等，最终都通过自行查询资料一一解决。通过这次实验，对线程相关知识点有了更深的理解，对课堂所学知识进行了综合整理。
## 实验源码
见本仓库代码部分

